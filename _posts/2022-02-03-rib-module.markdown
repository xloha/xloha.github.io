---
layout: post
title:  "(iOS) RIBs - 모듈화"
date: 2022-02-03 10:40:00 +0900
categories: ios
tags:
- iOS
- RIB
- architecture
- module
---

# 모놀리틱 앱 구조

1. 단일타겟(모듈)
2. 객체 간 무분별한 참조
3. 코드 변경의 영향 범위 파악이 힘듦
4. 빌드 시간 증가에 따른 생산성 저하

* 앱 타겟이 그 자체로 하나의 모듈
    * 별도의 프레임워크를 만들지 않는 이상 추가되는 모든 코드는 처음 생성된 단일타겟에 생성됨
    * 단일모듈상에서는 객체간의 참조 그래프가 매우 복잡해질 확률 증가
        * 둘 이상의 객체가 서로를 참조하는 순환참조가 나타남 
        * 순환참조가 발생하면 객체를 단독으로 사용할 수 없게되어서 결국 여러객체가 하나의 비대한 객체임;
        * public과 internal 접근자를 구분해서 쓸 수 없는 것이 가장 큰 이유임
        * 복잡한 기능을 개발할때는 여러객체가 협력해야할 때가 많은데 기능을 제공하는 입장에서는 객체 한두개만 노출하고 싶음
            * 하지만 한 모듈안에서는 private class로 만들어서 몽땅 한 파일에 넣지 않는 이상 같은 모듈안에서 객체를 숨길 수 있는 방법이 없음
            * 그렇다고 협력객체들을 몽땅 한 파일에 몰아넣고 private으로 만드는 것은 권장X
                * 처음부터 뚜렷한 설계없이 객체들을 만들다보면 객체간의 참조가 복잡해지고 어느 객체의 내부코드를 고쳤을 때 영향범위를 파악하기 힘듦
* 앱 빌드 시간 증가

---

* 모듈이 커지고 복잡해지면 나눠야함
    * 잘 나뉘어진 모듈은 계층화 할 수 있음
    * 상위에 있는 모듈은 하위에 있는 모듈에 접근할 수 있지만 하위에 있는 모듈은 상위에 있는 모듈에 접근하지 않도록 코드가 단방향으로만 참조할 수 있도록 설계하는 것이 가장 좋음
    * 단방향으로 흐르면 순환참조가 일어나지 않기 때문에 독립적이고 간단하고 명확한 모듈 구조를 가져갈 수 있음


* 상위 모듈과 하위 모듈의 구분

* 로직 상 구분
* interactor : 상위모듈
    * repository, UI : 중위 모듈
        * Networking, CoreData : 하위 모듈
* 화면 상 구분
* AppRoot : 상위 모듈
    * AppHome, FinanceHome: 중위 모듈
        * CardOnFile, SuperPayDashboard: 하위 모듈

* 어떤 측면에서 보든 모듈의 참조관계는 단방향으로만 흐름
    * 체계적인 설계를 통해 단방향으로 로직이 흐르게 모듈을 나눠놓으면 모놀리틱 앱 구조의 문제점을 상당수 해결할 수 있음
    * 다른 모듈에 노출하고 싶지 않은 객체나 데이터는 internal로 숨겨서 무분별한 참조를 차단할 수 있음
        * 외부참조가 끊겨있으니 코드를 변경하더라도 모듈 내부에서만 영향이 있을것이라고 확신가능

# 결국 모듈을 만드는 행위가 중요한게 아니라 객체간의 또는 로직별 코드 묶음간에 참조관계를 정리하는 것이 핵심임

# 참조관계가 정리되었다면 별도 프레임워크로 분리시키는 것은 소스코드를 이동시키는것 만큼이나 쉬운일임



# 의존성 주입 패턴
* 느슨한 결합을 달성하기 위해서는 의존성을 주입해줘야함
* 의존성을 주입은 의존성 역전을 달성하기 위한 구체적인 실행방법으로, 의존성역전이 사용된 코드에서는 객체들을 생성해서 주입해주는 지점이 존재해야만 하고, 이 지점을 Composition Root라고 부름

1. 생성자 주입
2. 메소드 주입
3. 프로퍼티 주입

Ex) RIBs의 Builder가 각 Riblet의 Composition Root임
* RepositoryImp
* ViewController
* Stream
* Router
* Interactor
등이 생성이 되고 객체들을 생성하면서 필요에 따라 Interactor나 Router나 ViewController의 생성자를 통해 의존성 주입이 됨

* Interactor와 router입장에서 봤을 때 생성자 주입임
* runtime에 바뀔 수 있는 값은 메소드를 통해 주입받음
    * build method의 파라미터를 통해서 값을 받는 것

* 프로퍼티 주입은 delegate를 세팅할 때를 생각하면 됨


# Composition Root를 제대로 활용하지 못할 경우
* 화면에 자신이 필요한 의존성만 가지고 있음
    * 화면이 추가되면 다음화면이 필요한 의존성을 이전화면이 들고 있음
    * 이런구조가 반복될수록 상위에 있는 화면은 자신에게 필요없는 의존성을 전부 가지고 있게 됨
* Composition Root를 이용해서 화면 생성에 필요한 의존성들을 Composition Root가 전부 들고있게 하고 각 화면을 생성하는 역할을 담당하게 하면 다음화면에 의존성을 이전화면이 들고있지 않게 만들 수 있음


# 어떤 의존성을 주입할지 말지 적절히 판단해야 함

### 모든 의존성이 다 주입되어야만 하는 것은 아님
* 의존성을 주입할지 말지는 의존성이 가지고 있는 동작의 특성에 따라 다름

### Volatile Dependency (주입해야하는 의존성)

* 동작이 유동적이고 실행할때마다 결과가 달라지는 의존성
    1. 사용하기 전에 Runtime에 초기화가 필요한 것
        * ex) 데이터베이스
    2. 아직 존재하지 않거나 개발중인 것
        * 구현체가 완성되기를 기다리기보다는 인터페이스를 먼저 주입해놓고 실구현체 없이 동작할 수 있게 만들 수 있음
    3. 비결정론적 동작/알고리즘
        * UUID string같은 random함수, Date() 같은 경우 안정적인 unit test를 작성할 수 없기 때문에 주입이 필요함

### Stable Dependency (주입할 필요 없는 의존성)

1. 결정론적 동작/알고리즘
    * ex) Formatter와 같이 input이 같으면 output도 항상 같은 것
2. 신뢰할만한 하위호환성
    * Foundation, RIBs 와 같은 것들 
3. Volatile 의존성을 제외한 모든 것 
